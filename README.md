# Project JENGA
Project JENGA code repository.

# Project Overview
Project JENGA (Just Everything Needed for Ground Architecture) is a a final project in the Spring 2019 semester of MEIE 4810 Introduction to Human Spaceflight, which is being taught at Columbia University by Professor Michael Massimino. The objective of Project JENGA is to design an architecture to take bricks made of Martian regolith (the composition and creation of the bricks is out of the scope of the project) and use it to create a useful structure. Then we will prototype the architecture in laboratory conditions, bringing it to Technology Readiness Level (TRL) 3. This is a novel idea.

Our technique at TRL 9 involves using a black body balloon (which we will likely simulate using a helium balloon) to generate buoyancy in the Martian atmosphere. The balloon will be connected via tether to four base stations spread out at equal distances and angles from each other. The balloon will be maneuvered over the construction site by varying the lengths of the tethers.
This repo is the site of the software developed for the project.

# Project Participants
Aaron Pickard, Albert Tai, Chris Fryer, Thomas Orr, Victoria Wang

# Code Overview
The goal of the software development in this project is to provide a meaningful instruction set to the hardware in a language that the hardware can understand. Due to the familiarity of other participants with the architecture, the software/hardware interface in Project JENGA occurs in G-Code. The G-Code statements will be generated by Python files written based on the paradigm of Object Oriented Programming (OOP). The files' roles, as well as the functions within the files, are described below.

# Workflow

The code operates for the most part in the [x,y,z] cartesian frame. That's how the start and end points are determined, and th path between them is calculated. Presently, the operational code calculates the path between the start point and the end point according to an algorithm, and then creates a path between them. The start point and orientation is identical for every block in the instruction set, as Project JENGA assumes that bricks are being produced at scale by an automated factory in the assembly space. The end point varies based on where the brick is being placed. The path as presently constructed has three parts.
1. Vertical ascent from the pickup point to a point some distance higher but at the same [x,y] coordinates
2. Horizontal transfer from the end of the vertical ascent point to a point located a distance above the placement point
3. Vertical descent to the placement point

We attempted to make the second step parabolic transfer instead of linear, but ran into implementation issues. The raison d'etre of the first and final steps are to avoid collissions with either brick manufacturing infrastructure (in the first step) and the structure under assembly (in the final step). 

# Increasing TRL
The work done so far brings Project JENGA to Technology Readiness Level (TRL) 3, which NASA defines as an "analytical and experimental...characteristic proof-of-concept" (https://www.nasa.gov/directorates/heo/scan/engineering/technology/txt_accordion1.html). All the work for this project was done in laboratory conditions. Increasing TRL requries modifying the code to operate in an analog environment. This would require modifying the code based on an understanding of Martian wind conditions, as well asmodifying the code such that the balloon can be made to move in a repeatable way - one issue we dealt with in working with the hardware was that instructions to the balloon were not easily repeatable. We hope this has to do more with the fact that this is a proof-of-concept for assembling structures using multitethered aerostat balloons than anything else, and that if further studies are conducted, the use of more precise hardware will address the issue. If the end effector is changed, code will need to change to account for that. The path planning could probably be optimized. Additionally, in order to reduce the possibility of hardware collissions between Project JENGA architecture and other surface architecture at the mission planning level, it should be defined that structures will be created not just from the bottom up, but from back to front, and that structures farther away from the brick-making factory will be constructed first.

# Python Files
## block.py
This file defines the notional brick we are using to build our structures and validate our architecture. Presently, each brick is 50mm x 25mm x 25mm, has two pyramid-shaped notches on top with bases of 25mm x 25mm to aid in construction, and is a hollow shell of 3D-printed plastic. The file defines the shape of the block in three dimensions, as well as the offsets necessary for the architecture to pick up and place the block appropriately using electromagnets and functions that can be used to adjust these values.

### Functions in block.py

__init__(self): creates a block object

set_block_length(self, n): allows the user to adjust brick length 

set_block_height(self, n): allows the user to adjust brick height

set_block_width(self, n): allows the user to adjust brick width

set_pt1_l_offset(self, n): allows the user to set the point of attachment point 1's length offset

set_pt1_w_offset(self, n): allows the user to set the point of attachment point 1's width offset

set_pt2_l_offset(self, n): allows the user to set the point of attachment point 2's length offset

set_pt2_w_offset(self, n): allows the user to set the point of attachment point 2's width offset

## gcode.py
This file facilitates the printing of the various statements that will move the balloon assembly. These statements will be written in G-Code, as a project member has significant experience working in it and with motors that use it. The functions in here will directly control the motion of the balloon assembly through a .txt file fed to a G-Code interpreter, and will also create .csv files that are easier to visualize for debugging and presentation purposes. Data can be printed to a terminal if desired, though this is not recommended.

### Functions in gcode.py

__init__(self): creates a gcode object

set_neutral(self): sets the neutral point, where the balloon assembly should rest when not in use, by modifying the goto point

set_pickup_point(self): sets the pickup point, where the balloon assembly picks up new bricks, by modifying the goto point

set_placement_point(self): sets the point where the brick is to be place, by modifying the goto point

set_goto_point(self, a, b, c): changing this point by entering an [x,y,z] point in parameters a, b, and c allows the user to change the neutral, pickup, and placement points, which can only be changed by setting the goto point

set_feed_rate(self, f): sets the feed rate, which should always be in mm/s

set_units(self): sets the units of the system to mm - G-Code works in mm or inches but our bricks are built to mm dimensions, 50mm x 25mm x 25mm (which is roughly 2in x 1in x 1in, but mm is more precise)

set_separation_height(self, h): allows the user to set the height of the initial vertical climb and final terminal descent of the brick, to avoid collisions with architecture in the vicinity of the brick-making or construction sites, or on the path between them.

set_step_size(self, s): allows the user to set the size of steps for all functions, which move the brick in steps in order to reduce the stress on the tethers, balloon, and end effector

pickup_brick(self, place): instructs the end effector to pick up a brick

putdown_brick(self, place): instructs the end effector to put down a brick

move_brick_to_placement(self, start, stop): DEPRECATED FUNCTION, attempts to be all-in-one function that calls the vertical motion function, implements parabolic motion in two dimensions twice to move to the [x,y] coordinates of the putdown point, and then descends to the putdown point

move_parabola_xz(self, start, stop): DEPRECATED FUNCTION, moves the brick along parabolic arc in the xz frame (it still works and may be necessary for optimizing the path planning, but current implementation does not use it)

move_parabola_yz(self, start, stop): DEPRECATED FUNCTION, moves the brick along parabolic arc in the yz frame (it still works and may be necessary for optimizing the path planning, but current implementation does not use it)

move_parabola_xyz(self, start, stop): DEPRECATED FUNCTION, sequentially calls move_parabola_xz() and move_parabola_yz() (it still works and may be necessary for optimizing the path planning, but current implementation does not use it)

make_parabola(self, x1, y1, x2, y2, x3, y3, static_var, static_val): DEPRECATED FUNCTION, constructs a parabola based on the data passed to it from one of the above three functions (the third point is defined parametrically based on the first two points) and sends it to the printing function (it still works and may be necessary for optimizing the path planning, but current implementation does not use it)

move_vertical(self, start, h): vertically moves a brick up a defined distance

move_horizontal(self, start, stop): DEPRECATED FUNCTION, function that attempted to move the brick between two points by breaking down the best way to get there into a unit vector and then multiplying that by some constant so that the balloon moves the step size every step (it does not work, and while it may be necessary to optimize path planning, it caused serious enough issues that this strategy was dropped)

print_comment(self, text): prints a comment into the G-Code output file

print_command(self, position_list): converts motion commands to pick up, bring the brick to a set [x, y, z] location, and put it down to G-Code, and prints them to an output file

set_tether_length(self): adjusts the maximum tether lengths 

move_orrian_algo(self, start, stop): algorithm developed by Thomas Orr to move a brick between two points
1. Find length in xy plane between the start and stop points
2. Create a 2D map with the start point at [0,z] and the stop point at [length,z], where length is the distance in the xy plane between the (coplanar in the z-plane) start and stop points
3. Calculate the discretized parabola (though since the parabola operand value is 0, it winds up being a straight line) for the 2D map case
4. Convert the discretized parabola (line) back to 3D, by mapping x range in xy plane to the length range, and the y range in the xy plane to the length range (this part may not be implemented optimally, but it works well enough for the code to integrate with the hardware and produce the desired results because there's a failsafe G1 command to get to the stop point)

move_down(self, start, h): vertically moves a brick down a defined distance
    
## main.py
This is the file that brings all of these other files together and produces a meaningful G-Code instruction set for the balloon assembly to execute.

### Functions in main.py

This file contains no functions.

## my_utils.py
This is the file where I am throwing any miscellaneous functions I determine that I need but may not belong in a particular class, or may need to be used in multiple classes. It contains functions that check .csv output files for illegal or erroneous output, as well as functions that visualize the path of the end effector and the location of bricks that it places.

### Functions in my_utils.py

in_to_mm(input): takes an inches value and converts it to mm

map_from_arduino(x, in_min, in_max, out_min, out_max): reverses the mapping of [x,y,z] to [length,z] in move_orrian() in gcode.py, this function is called on both the x and y values

find_max_z_value(file_name): finds the maximum z-value in a .csv file, and prints out the value and where the value occurs in the command line

find_illegal_tether_length(file_name, tether_len): identifies illegal (distance to base station exceeds length of tether) tether lengths and prints them in the command line, as well as the other tether lengths where the illegal value occurs

show_path(): constructs a matplotlib scatter plot of a hardcoded .csv file containing the [x,y,z] coordinates of every end effector position in the instruction set defined by the file

show_path_2(): DEPRECATED, nonfunctioonal attempt to show the path described in show_path() in multiple colors

show_putdown_points(): constructs matplotlib scatter plot of a hardcoded .csv file containing in [x,y,z] coordinate form the putdown points of bricks 

## path_to_wall.py
In this file, is a plan for a path to construct a structure (at this point the structure is a simple wall). 

Project JENGA implements a path plan that works and may be reasonably efficient, but for reasons of compatibility with the hardware, not nearly as efficient as anything along the lines of what Correll, et al. suggest in their 2013 paper "Assembly Path Planning for Stable Robotic Construction" (http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1013.2520&rep=rep1&type=pdf). This is a key place where the architecture could be improved upon. The inputs for the code and the helper function are implemented in the Fancy(object) class.

Efficiency is considered here to be measured in the number of lines of instructions of G-Code given to the base station controllers. It is measured in this way with the goal of minimizing system power requirements. It competes against the desire to have small motor step sizes, due to the desire to not stress the hardware, and the need to have precision in placement location.

### Functions in path_to_wall.py

Within the Basic(object) class

__init__(self): creates a Basic path object
    
load_pickup(self, x, y, z): interfaces with G-Code to adjust the pickup point
    
load_putdown(self, x, y, z): interfaces with G-Code to adjust the putdown point
    
load_neutral(self, x, y, z): interfaces with G-Code to adjust the neutral point

move_brick(self, pickup, putdown): interfaces with gcode.py to pick up a brick, move it up vertically, move it to the putdown [x,y] position using move_orrian_algo(), and move the brick to the putdown point vertically

move_back_to_pickup(self): interfaces with gcode.py to move the end effector sans brick to the putdown point

move_lateral(self, pickup, putdown): calls move_orrian_algo() to move a brick between two points, called pickup and putdown

next_brick_in_x_row(self, putdown): adjusts the putdown point for the next brick in a row along the x axis (length)

next_brick_in_y_row(self, putdown): adjusts the putdown point for the next brick in a row along the y axis (width)

next_horizontal_x_row(self, putdown): creates a new row in the x axis, starting from the initial putdown point but over the width of a brick

next_horizontal_y_row(self, putdown): creates a new row in the y axis, starting from the initial putdown point but over the length of a brick

next_vertically_stacked_row(self, putdown, offset_sign): creates a new row in the z axis on top of an existing row of bricks (otherwise it'll just fall to the surface or the topmost row of bricks), starting from the initial putdown point, but up the height of a brick, offset either plus half the length of a brick, minus half the length of a brick, or with no offset (not recommended)

initialize(self): removes old output files, interfaces with gcode.py to set separation height, units, and "wake up" the end effector such that it thinks it is at the brick factory

algo2(self): algorithm to construct a notional 12-brick wall of 3 4-brick rows with the middle row offset from the top and bottom rows (which enables it to be used as part of a structure), and which moves bricks from the pickup point to the placement point using move_orrian_algo()
    
algo(self): DEPRECATED, assembly algorithm that does what algo2() does but less well



Within the Fancy(object) class:

__init__(self): DEPRECATED, never implemented, theoretically creates a Fancy path object
    
algo(self, g, σ_limit): DEPRECATED, never implemented, would theoretically implement the algorithm described in "Assembly Path Planning for Stable Robotic Construction"
    
backtrack(self): DEPRECATED, supports function that was never implemented, helper function for the algorithm

## tests.py
In this file are the tests that I wrote in order to debug my code, especially towards the end of the development process after I figured out how to visualize the path of the end effector.

### Functions in tests.py
test1(): tests the ability to call gcode.py functions and move a single brick from a pickup point to a putdown point

test2(): tests the ability to move the end effector up and then down

test3(): tests ability to assemble a row of bricks

# Output Files

## output_coordinates.csv
This file contains the [x,y,z] coordinates of every G-Code instruction, for debugging and visualization purposes.

## output_instructions.csv
This file contains the [X,Y,Z,A] tether lengths of every G-Code instruction, for debugging and visualization purposes.

## output_instructions.txt
This file contains G-Code that is fed into a computer controlling the hardware of Project JENGA to execute an instruction set detailing an assembly path.

## output_points.csv
This file contains the [x,y,z] coordinates of every G-Code command to place a brick, for debugging and visualization purposes. 
